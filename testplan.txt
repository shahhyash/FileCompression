Our code was tested rigorously through randomly generated test data. The script grader.py creates a randomly generated text file with a random number of characters in the file between 1 and N. We change the parameter N to be a value in {10, 100, 1000, 10000, 100000, 1000000}. The script randomly generates an ascii character and writes it to the text file and an answer file until N characters are written. Then the script cleans and makes the fileCompressor executable. The script runs fileCompressor to build the HuffmanCodebook, then compress the file, then decompress the file. The decompressed file is checked against the answers file for accuracy. Running this script for 10 minutes continuously (of varying N), our simulation shows only passing testcases.

Similarly, we have implemented a recursive option (python3 grader.py -R)to rigorously test our code functionality. In this case, we randomly generate subdirectories within a directory that is created by the script called recursive_test. Similarly to the non-recursive case, the script generates a random number of files within a directory between 1 and M. Afterwards for each item (directory or file) created within recursive_test, either the creation function is called again in the case of a subdirectory creation or the file randomly generates a set of 1 to N ascii characters (as in the non-recursive case). At the same time, the file structure is created in duplicate within recursive_test_ans for later accuracy testing. Once the test data has been created, the script cleans and makes fileCompressor. Then it is called to build, compress, and decompress recursively on recursive_test. Afterwards, each compressed .hcz file is deleted from recursive_test and its subdirectories. The difference between all the files within recursive_test and recursive_test_ans is compared. If there are errors, they are stated. Otherwise, the program prints "All tests passed!" and returns. Running this script many times successfully shows that our program is robust.

The HuffmanCodebook, AVL tree, and heap were checked on small test cases by hand to make sure that they worked properly. The AVL tree was printed with traverse(root) after elements were added to ensure that each rotation was performed in the correct instance.

We also tested a few edge cases manually. We ran fileCompressor with only one token and only two tokens to ensure that it built the codebook, compressed, and decompressed properly. We also manually tested to make sure erroneous cases gracefully exit. We tested blank file inputs, blank directory inputs, improper flags (which includes using a file for a directory and vice verse), and invalid names for files and directories.

Due to the nature of our rigorous testing, there may be other typically trivial test cases that we did not write about here. Many of these are automatically tested by our autograding script.
